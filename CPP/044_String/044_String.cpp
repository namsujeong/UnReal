// 044_String.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
    // 문자는 사실 컴퓨터에게는 의미가 없다.
    // 인간은 문자를 사용하지 않고 뭔가를 표현하는게 정말 힘듭니다.
    // 그래서 필연적으로 어떠한 문자를 표현하는것이 언어적 기본으로 제공되어야 했습니다.

    // 문자를 표현하는 방식은 무조건
    // n바이트의 메모리에 글자 1개를 배칭시킨다.
    // 문자를 표현하는 바이트 방식은 정말정말 다양하고
    // 이것을 인코딩이라고 말합니다.
    // 문자열 인코딩이 뭐냐?
    // 문자를 표현하는 표현방식 자체를 인코딩이라고 합니다.
    
    // 0. 기본을 잊으면 안된다.
    // 문자는 무조건 0 == a
    //       00000000 == 'a'
    // 문자는 무조건 1 == b
    //       00000001 == 'b'
    // 문자는 1개의 비트상태와 매칭된다.

    // 어떤 인코딩 방식은 1바이트에 문자 1개를 표현
    // 어떤 인코딩 방식은 1~2바이트에 문자 1개를 표현
    // 어떤 인코딩 방식은 1~3바이트에 문자 1개를 표현
    // 어떤 인코딩 방식은 2바이트에 문자 1개를 표현
    // 인코딩 방식은 왜 이렇게 다양하게 표현되게 됐을까요.

    // 아스키
    // 최초의 문자열 인코딩은 아스키방식이라고 하고
    // 1바이트에 문자를 매칭시키는 방식이었습니다.
    // 1바이트의 최대치는 0~255
    // 255개의 글자를 매칭시킬수가 있었고 초기에는 이걸로도 충분했습니다.
    // 0 1 2 3 4 5 7 8 9 
    // abcdefghijk.......
    // 프로그래밍은 서구권에서 시작했기 때문에 이걸로도 충분했어요.
    // 그리고 이때의 매칭 방식을 아스키 인코딩이라고 합니다.

    // 안시(멀티바이트)
    // 글로벌화 되면서 다양한 언어의 글자를 표현해야할 필요가 생겼습니다.
    // 가나다라마바사아자차꿸꾸얻
    // 그래서 2바이트로 표현하는 필요하겠네? 0~65535개를 표현할수 있는
    // 2바이트형 문자들과 조합해서 1~2바이트의 문자를 표현하는 
    // 멀티바이트 인코딩 방식이 생겼습니다.

    // 유니코드(와이드바이트)
    // 아니 뭘 귀찮게 1~2바이트로 하냐
    // 온리 2바이트로 하자.
    
    // 모든언어들이 문자를 표현하기 위한 자료형이 따로 만들어졌고
    // 여기까지해서 프로그래밍에서 기본적으로 문자를 처리할때는 와이드 바이트와 멀티바이트를 섞어서
    // 쓰자고 했습니다.
    char multibyte = 'a'; // 어떤때는 1바이트 어떤때는 2바이트
    wchar_t widebyte = L'a'; // 모조리 2바이트
    // 이 두가지 표현방식은 아스키의 매칭방식을 그대로 씁니다.
    // 아스키의 매칭방식을 안쓰는 인코딩을 찾기가 더 어려울것입니다.

    // 0~65535안에 한글과 한자를 아랍어 모두 담을수 있을까요? 
    // 이게 또 안되는 겁니다.
    // 한국 20000 = 가
    // 중국 20000 = 卍
    // 이걸 국가코드라고 합니다.
    // 각 나라별로 있습니다.
    // 이런 2바이트 표현으로는 각 나라의 최적화된 문자 표현을 하게 됩니다.

    // 그래서 나온것들이 UTF시리즈가 나오기 시작했습니다.
    // 옛날이나 메모리 아끼려고 2바이트로 국가별로 표현했지
    // 요즘시기에 무슨 글자하나 표현하는데 1~4바이트까지 쓰자.
    // 이렇게 해서 나온게
    // utf-8
    // utf-16
    // 이런식으로 표현하게 되었습니다.

    // 변환함수는 지원해도
    // 코딩에서는 언제나 멀티바이트와 와이드 바이트만 지원합니다.

    // 그런데 우리가 코드를 칠때는 어떻게 쓰이는 건가요?
    const char* MultiPtr = "멀티바이트";
    const wchar_t* WidePtr = L"와이드바이트";
    // 이 두가지가 아닌 다른 인코딩으로 바꿔야겠는데?

    // utf_8형 문자열도 언어적차원에서 지원을 해줍니다.
    const char* UTF8Ptr = u8"UTF_8";
    int a = 0;

    //         000000001 000000001 000000001 000000001
    bool Arr[4] = {true,      true,     true,     true};

    int* Ptr = reinterpret_cast<int*>(Arr);
}
